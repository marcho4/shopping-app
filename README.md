# Shopping App

Full-Stack приложение с реализацией микросервисной архитектуры, MVVM архитектуры на фронт энде и transactional inbox/outbox паттернами с гарантией доставки Exactly Once

## Описание решения

Всего есть три микросервиса:
- Api Gateway
- Orders 
- Payments

Для каждого микросервиса выделяется своя БД PostgreSQL, а также созданы SQL миграции, которые выполняются при запуске приложения.

Каждый из микросервисов выполняет задачи по ТЗ:
- Api Gateway корректно проксирует запросы
- Orders позволяет:
    - Создать заказ
    - Посмотреть статус конкретного заказа
    - Посмотреть все заказы пользователя
- Payments позволяет:
    - Создать банковский аккаунт
    - Положить деньги на аккаунт
    - Получить баланс аккаунта
    - Посмотреть аккаунт для конкретного пользователя


Документация к API доступна по 
`http://localhost:8000/swagger-ui/#/`.(Вообще у микросервисов Orders и Payments тоже есть своя документация, надо только порт сменить в ссылке, чтобы посмотреть, а так ссылка одинаковая).

### Очередь сообщений и реализация создания заказов

Очередь сообщений: Kafka. 

Таски на создание заказа отправляются в JSON формате в топик `outbox`. 

Таски на обновление статуса заказа отправляются в топик `inbox`.

Топики автоматически создаются при старте приложения.

При отправке задачи на оплату заказа используется гарантия At Least Once.
(Статус в Outbox таблице меняется на отправленный только после подтверждения отправки сообщения в Kafka).

При принятии сообщения из кафки, в сервисе Payments, задача добавляется в таблицу inbox только если order_id ни с кем не конфликтует - реализовано через SQL запрос. За счёт этого и выполняется гарантия доставки Exactly Once.

При отправке update'a обратно в Orders из Payments реализована семантика, аналогичная outbox'у из Orders. 

### Архитектура интерфейса

Интерфейс реализован в виде веб приложения на React с использованием фреймворка Next.js. Для реализации была выбрана архитектура MVVM.

В `lib/viewModels` находятся React Hooks, которые являются viewModels в данном контексте.

В `components` лежат View компоненты, которые не содержат никакой бизнес логики, а только используют данные из ViewModel.

В `lib/models` лежат соответственно модели, используемые в приложении.

Все запросы происходят на серверной части приложения.

### Тестирование

Для тестирования были написаны интеграционные тесты. Для запуска нужно:
1. Запустить приложение
2. Выполнить команду 
```bash
cd gateway && cargo test
```

Сценарий для тестирования:

1. Попытка заказа не имея банковского аккаунта - ожидаем reject
2. Создание аккаунта
3. Повторное создание аккаунта и сверка двух id на идентичность
4. Попытка заказа без денег
5. Пополнение отрицательным кол-вом денег счет и проверка что баланс не изменился
6. Адекватное пополнение и проверка что баланс изменился
7. Покупка дешевого товара и проверка статуса заказа + списания денег
8. Покупка дорогого товара и проверка того, что заказ в статусе Rejected и деньги не списались
9. Проверка получения заказов для нашего mock юзера
10. Проверка получения банковского счета для mock юзера и сверка баланса

На мой взгляд охватывает весь функционал приложения.

### Инструкция по запуску приложения

1. Зайти в корневую папку репозитория 
2. Создать .env файл 
3. Выполнить команду
```bash
docker compose up -d
```
4. Зайти на http://localhost:3000 для доступа к интерфейсу